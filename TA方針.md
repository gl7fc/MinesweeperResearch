# 概要

本ドキュメントは, マインスイーパの各セルが「どのレベルのテクニック」を用いれば論理的に確定可能かを判定するプログラムの設計方針をまとめたものである. 

# レベル別アルゴリズム設計
## 推論テクニックの分類
1. 背理法が不要
   1. 埋めるだけ
   2. 包含①
   3. 包含②
   4. 共通
2. 背理法が必要

## Lv1-1. 埋めるだけ
### 入力: 
開いているヒントセル $H$

### 情報:

- $U$: $H$ の周囲にある未確定セル数
- $F$: $H$ の周囲にある地雷確定セル数（旗）
- $V$: $H$ の数字

### 判定ロジック:

- 残りすべて地雷
  - $V = F + U$ ならば、残りの未確定セル $U$ はすべて 地雷。
- 残りすべて安全
  - $V = F$ ならば、残りの未確定セル $U$ はすべて 安全。

## Lv1-2/3. 包含
2つのヒント（または Region） $A, B$ の関係を利用する。
$A$ の対象セル集合 $S_A$ が、$B$ の対象セル集合 $S_B$ の部分集合である場合 ($S_A \subset S_B$) に発動する。

### 前提: 
ヒント $A, B$ の片方の未確定セルの集合がもう片方の未確定セルの集合を包含している。

### 判定ロジック:

- $S_A \subset S_B$ であるかチェックする（Javaの Set.containsAll を利用）。
- 差分領域 $D = S_B - S_A$ を計算する。
- $D$ に含まれる地雷数 $M_D = M_B - M_A$ を計算する。

### Lv1-2 (確定):

- $M_D = |D|$ (差分のセル数) なら、$D$ はすべて 地雷。
- $M_D = 0$ なら、$D$ はすべて 安全。

### Lv1-3 (情報の伝播):

- 上記以外の場合、セルは確定しないが、新たな制約「領域 $D$ には地雷が $M_D$ 個ある」が得られる。
- この新しい Region $D$ をヒントリストに追加し、他のヒントとの組み合わせ（Lv1-2やLv1-4）に再利用する。
  
## Lv1-4. 共通
2つのヒント $A, B$ が共通部分を持つが、包含関係にはない場合。

### 領域定義:

- $OnlyA = S_A - S_B$ （Aのみにあるセル）

- $Common = S_A \cap S_B$ （共通セル）

- $OnlyB = S_B - S_A$ （Bのみにあるセル）

### 判定ロジック:

- $Common$ に存在しうる地雷数の 最小値($minC$) と 最大値($maxC$) を計算する。

  - $maxC = \min(|Common|, M_A, M_B)$

  - $minC = \max(0, M_A - |OnlyA|, M_B - |OnlyB|)$

- この $min/max$ を使って、$OnlyA$ や $OnlyB$ の地雷数を絞り込む。

- もし $M_A - minC = |OnlyA|$ なら、$OnlyA$ はすべて地雷確定。

- もし $M_A - maxC = 0$ なら、$OnlyA$ はすべて安全確定。

  - ($OnlyB$ についても同様)

## Lv2. 背理法 (Trial & Error / Contradiction)

Lv1の手法ですべて詰まった場合に発動する。
「仮定」をおいて矛盾を探すシミュレーション。

### 判定ロジック: 
DLXによって実装済み. 

# クラス設計方針
## データ構造 `Region`
### 概念
「盤面の数字ヒント」と「推論によって得られた仮想的なヒント」を同じ推論材料として統一して扱うためのデータ構造。

### 定義
「このセル集合の中に、地雷があと $N$ 個ある」という制約情報。

### 不変性
このクラスは一度作成したら中身を変更しない。
情報が更新されるときは、「古い Region を捨てて、新しい Region を作り直す」。
これにより、情報の整合性を保ちやすく、バグを防ぐ。

### 使用方針
初期状態では盤面上の各ヒント数字から `Region` が生成される. 
推論が進むにつれて, 領域の共通部分や差分から新しい推論材料として `Region` が生成される. 

## 推論エンジン `TechniqueAnalyzer`
### 概念
盤面全体の状態を管理し, 推論のステップを進めるコントローラー. 

### 処理フロー
#### 初期化
盤面のすべての数字ヒントを走査し, 最初の `Region` リストを作成する. 
#### ループ
「簡単な手法から順に試す」という方法でパズルを推論する. 
確定するセルがあれば直ちに「更新処理」を行い, ループの最初に戻る. 

1. Lv1-1 (埋めるだけ) を試す. 
2. Lv1-2, 3 (包含) を試す. 
3. Lv1-4 (共通) を試す. 
4. Lv2 (背理法) を試す. 

#### 更新処理
複数のセルが同時に確定した際の不整合を防ぐため, 以下の順序で処理を行う. 

##### 1. 盤面の完全更新
確定したすべてのセルを `currentBoard` に反映させる. 
##### 2. 新規 `Region` の生成
新しく開いた数字セルから `Region`を生成する. 1. で盤面が最新化されているため, 隣接セルの状態を正しく参照できる. 
##### 3. 既存 `Region` の更新
リスト内の既存 `Region` から, 今回確定したセルを取り除く. 
##### 4. マージ
新規作成した `Region` と更新された既存 `Region` を合わせ, 重複を排除してリストを更新する. 
# 詳細設計
## データクラス `Region`
### フィールド
- `Set<Integer> cells`: この領域に含まれる未確定セルのインデックス集合。
- `int mines`: この領域内に存在する地雷の数。
- `originLevel`: この情報が生成されたテクニックのレベル. 盤面上の数字ヒントは `originLevel = 0`, Lv1-3で生成されたヒントは `originLevel = 3`. 

### メソッド
- `isSubsetOf(Region other)`: 自分が相手の部分集合かどうか判定。
- `subtract(Region other)`: 差分領域（自分 - 相手）を新しい `Region` として返す。この際, 新しい `Region` のレベルは `max(this.level, other.level, 3)` とする. 
- `toString()`: デバッグ用（例: `"{10, 11, 12} = 1"`）。

## 解析クラス `TechniqueAnalyzer`
### フィールド

- `int[] board`: 現在の盤面状態（常に最新を維持）。
- `int[] completeBoard`: 正解盤面（推論結果の検証用）。
- `int[] difficultyMap`: 各セルの確定にかかったテクニックレベルを記録。
- `List<Region> activeRegions`: 現在有効な推論の手がかりリスト。

### メソッド

- `analyze()`: 解析のメインループ。
  - `initRegions()` で初期化。
  - 変化がなくなるまでループ:
    1. `solveLv1_1()`
    2. `solveLv1_2()` ...
- `initRegions()`: 盤面上の数字ヒントを走査し、初期の `Region` リストを生成する。
  - 数字セルを見つけ、その周囲の「未確定セル」を集めて `Region` を作成。
- `applyResult(Map<Integer, Integer> deduced)`: 推論で確定したセル（Safe/Mine）を盤面に反映する。
  - 盤面 `board` を更新。
  - `activeRegions` 内の各Regionからも、確定したセルを除去し、地雷なら `mines` を減らす処理を行う。

### Lv1-1 実装内容
#### `SolveLv1_1` ロジック詳細
リスト内の各 `Region` について, 以下の条件をチェックする. 
- 全地雷パターン (`mines == cells.size`): `cells` すべてが地雷 (`FLAGGED`). 
- 全安全パターン (`mines == 0`): `cells` すべてが安全 (`Safe`). 

### Lv1-2/3 実装内容
#### 1. 探索ループ
`activeRegion` リストから2つの `Region(A, B)` を選ぶ2重ループを行う.
$A$ と $B$ が共通部分を持たない場合はスキップする.
#### 2. 包含判定
`Region B`が `Region A` を完全に含んでいるか確認する. 

#### 3. 差分計算
包含関係があれば, 差分領域 $D = B - A$ を生成する. 

#### 4. 状態判定
##### A. 即確定できる(Lv1-2)
差分領域 $D$ が全て地雷または全て安全. 
1. $D$ に含まれるセルを確定リストに追加. 
2. 難易度は `max(LV_1_2, D.originLevel)`
3. 盤面更新・ループ脱出
   
##### B. 即確定できない(Lv1-3)
ケースA. に該当しない, かつ $D$ が既存のリストに存在しない新しい情報であるとき. 
1. $D$ の `originLevel` をLv3に設定. 
2. `activeRegion` に $D$ を追加. 
3. ループ脱出